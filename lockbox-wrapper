#!/usr/bin/env python3
import glob
import grp
import hashlib
import json
import os
import pwd
import shlex
import stat
import sys

os.umask(0o002)

WORK_DIR = "/work"

CONFIG_PATH = "/etc/lockbox/allowed.json"


def load_allowed():
    """Load allowed commands from JSON config file."""
    try:
        with open(CONFIG_PATH, "r") as f:
            allowed = json.load(f)
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError as e:
        sys.stderr.write(f"Error: invalid JSON in {CONFIG_PATH}: {e}\n")
        sys.exit(1)

    if not isinstance(allowed, dict):
        sys.stderr.write(f"Error: {CONFIG_PATH} must contain a JSON object\n")
        sys.exit(1)

    return allowed


ALLOWED = load_allowed()

BUILTINS = {
    "list-files",
    "get",
    "put",
    "remove-file",
    "remove-dir",
    "remove-dir-recursive",
    "create-dir",
    "move-file",
    "copy-file",
    "file-info",
    "file-exists",
    "file-hash",
    "disk-usage",
    "search-files",
    "append-file",
}

ALL_COMMANDS = sorted(list(ALLOWED.keys()) + list(BUILTINS))


def safe_path(user_path):
    """Resolve user_path to an absolute path under WORK_DIR.
    Returns the resolved path or None if it escapes WORK_DIR."""
    if not user_path:
        return WORK_DIR

    if user_path.startswith("/"):
        joined = os.path.join(WORK_DIR, user_path.lstrip("/"))
    else:
        joined = os.path.join(WORK_DIR, user_path)

    resolved = os.path.realpath(joined)

    if resolved != WORK_DIR and not resolved.startswith(WORK_DIR + "/"):
        return None

    return resolved


def die(msg):
    sys.stderr.write(f"Error: {msg}\n")
    sys.exit(1)


def format_mode(st_mode):
    parts = []
    for who in ("USR", "GRP", "OTH"):
        r = "r" if st_mode & getattr(stat, f"S_IR{who}") else "-"
        w = "w" if st_mode & getattr(stat, f"S_IW{who}") else "-"
        x = "x" if st_mode & getattr(stat, f"S_IX{who}") else "-"
        parts.append(r + w + x)

    return "".join(parts)


def owner_name(uid):
    try:
        return pwd.getpwuid(uid).pw_name
    except KeyError:
        return str(uid)


def group_name(gid):
    try:
        return grp.getgrgid(gid).gr_name
    except KeyError:
        return str(gid)


def file_info_json(path):
    st = os.stat(path)
    is_dir = stat.S_ISDIR(st.st_mode)
    return {
        "name": os.path.basename(path),
        "size": st.st_size,
        "modified": int(st.st_mtime),
        "isDir": is_dir,
        "mode": format_mode(st.st_mode),
        "owner": owner_name(st.st_uid),
        "group": group_name(st.st_gid),
        "links": st.st_nlink,
    }


def cmd_list_files(args):
    as_json = False
    paths = []
    for arg in args:
        if arg == "--json":
            as_json = True
            continue
        paths.append(arg)

    target = safe_path(paths[0] if paths else "")
    if not target:
        die("path outside /work")

    if not os.path.exists(target):
        die("no such file or directory")

    if not os.path.isdir(target):
        if as_json:
            sys.stdout.write(json.dumps([file_info_json(target)]) + "\n")
            return
        sys.stdout.write(os.path.basename(target) + "\n")
        return

    try:
        entries = sorted(os.listdir(target))
    except PermissionError:
        die("permission denied")

    if as_json:
        result = []
        for entry in entries:
            result.append(file_info_json(os.path.join(target, entry)))
        sys.stdout.write(json.dumps(result) + "\n")
        return

    for entry in entries:
        if os.path.isdir(os.path.join(target, entry)):
            sys.stdout.write(entry + "/\n")
            continue
        sys.stdout.write(entry + "\n")


def cmd_get(args):
    if not args:
        die("usage: get <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if not os.path.isfile(target):
        die("no such file")

    with open(target, "rb") as f:
        while True:
            chunk = f.read(65536)
            if not chunk:
                break
            sys.stdout.buffer.write(chunk)


def cmd_put(args):
    if not args:
        die("usage: put <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    parent = os.path.dirname(target)
    if not os.path.isdir(parent):
        die("parent directory does not exist")

    with open(target, "wb") as f:
        while True:
            chunk = sys.stdin.buffer.read(65536)
            if not chunk:
                break
            f.write(chunk)


def cmd_remove_file(args):
    if not args:
        die("usage: remove-file <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if target == WORK_DIR:
        die("cannot remove /work")

    if not os.path.exists(target):
        die("no such file or directory")

    if os.path.isdir(target):
        die("is a directory, not removing")

    os.remove(target)


def cmd_remove_dir(args):
    if not args:
        die("usage: remove-dir <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if target == WORK_DIR:
        die("cannot remove /work")

    if not os.path.isdir(target):
        die("not a directory")

    if os.listdir(target):
        die("directory not empty")

    os.rmdir(target)


def cmd_remove_dir_recursive(args):
    if not args:
        die("usage: remove-dir-recursive <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if target == WORK_DIR:
        die("cannot remove /work")

    if not os.path.isdir(target):
        die("not a directory")

    import shutil

    shutil.rmtree(target)


def cmd_create_dir(args):
    if not args:
        die("usage: create-dir <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    os.makedirs(target, exist_ok=True)


def cmd_move_file(args):
    if len(args) < 2:
        die("usage: move-file <src> <dst>")

    src = safe_path(args[0])
    if not src:
        die("source path outside /work")

    dst = safe_path(args[1])
    if not dst:
        die("destination path outside /work")

    if not os.path.exists(src):
        die("no such file or directory")

    parent = os.path.dirname(dst)
    if not os.path.isdir(parent):
        die("destination parent directory does not exist")

    os.rename(src, dst)


def cmd_copy_file(args):
    if len(args) < 2:
        die("usage: copy-file <src> <dst>")

    src = safe_path(args[0])
    if not src:
        die("source path outside /work")

    dst = safe_path(args[1])
    if not dst:
        die("destination path outside /work")

    if not os.path.isfile(src):
        die("no such file")

    parent = os.path.dirname(dst)
    if not os.path.isdir(parent):
        die("destination parent directory does not exist")

    import shutil

    shutil.copy2(src, dst)


def cmd_file_info(args):
    if not args:
        die("usage: file-info <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if not os.path.exists(target):
        die("no such file or directory")

    sys.stdout.write(json.dumps(file_info_json(target)) + "\n")


def cmd_file_exists(args):
    if not args:
        die("usage: file-exists <path>")

    target = safe_path(args[0])
    if not target:
        sys.stdout.write("false\n")
        return

    if os.path.exists(target):
        sys.stdout.write("true\n")
        return

    sys.stdout.write("false\n")


def cmd_file_hash(args):
    if not args:
        die("usage: file-hash <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if not os.path.isfile(target):
        die("no such file")

    h = hashlib.sha256()
    with open(target, "rb") as f:
        while True:
            chunk = f.read(65536)
            if not chunk:
                break
            h.update(chunk)

    sys.stdout.write(h.hexdigest() + "\n")


def cmd_disk_usage(args):
    target = safe_path(args[0] if args else "")
    if not target:
        die("path outside /work")

    if not os.path.exists(target):
        die("no such file or directory")

    if os.path.isfile(target):
        sys.stdout.write(str(os.path.getsize(target)) + "\n")
        return

    total = 0
    for dirpath, _dirnames, filenames in os.walk(target):
        for fname in filenames:
            total += os.path.getsize(os.path.join(dirpath, fname))

    sys.stdout.write(str(total) + "\n")


def cmd_search_files(args):
    if not args:
        die("usage: search-files <pattern>")

    pattern = args[0]
    matches = glob.glob(pattern, root_dir=WORK_DIR, recursive=True)

    for match in sorted(matches):
        full = os.path.join(WORK_DIR, match)
        if os.path.isdir(full):
            sys.stdout.write(match + "/\n")
            continue
        sys.stdout.write(match + "\n")


def cmd_append_file(args):
    if not args:
        die("usage: append-file <path>")

    target = safe_path(args[0])
    if not target:
        die("path outside /work")

    if not os.path.isfile(target):
        die("no such file")

    with open(target, "ab") as f:
        while True:
            chunk = sys.stdin.buffer.read(65536)
            if not chunk:
                break
            f.write(chunk)


def _load_environment():
    """Load /etc/environment into os.environ for vars sshd doesn't pass through."""
    try:
        with open("/etc/environment") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                k, _, v = line.partition("=")
                os.environ.setdefault(k, v)
    except FileNotFoundError:
        pass


def main():
    _load_environment()
    cmd = os.environ.get("SSH_ORIGINAL_COMMAND", "").strip()

    if not cmd:
        try:
            with open("/etc/lockbox/user", "r") as f:
                name = f.read().strip()
        except FileNotFoundError:
            name = "lockbox"
        sys.stderr.write(f"Usage: ssh {name}@host '<command> [args]'\n")
        sys.stderr.write(f"Allowed commands: {', '.join(ALL_COMMANDS)}\n")
        sys.exit(1)

    try:
        parts = shlex.split(cmd)
    except ValueError as e:
        die(f"invalid command syntax: {e}")

    if not parts:
        die("empty command")

    binary = parts[0]
    args = parts[1:]

    builtins = {
        "list-files": cmd_list_files,
        "get": cmd_get,
        "put": cmd_put,
        "remove-file": cmd_remove_file,
        "remove-dir": cmd_remove_dir,
        "remove-dir-recursive": cmd_remove_dir_recursive,
        "create-dir": cmd_create_dir,
        "move-file": cmd_move_file,
        "copy-file": cmd_copy_file,
        "file-info": cmd_file_info,
        "file-exists": cmd_file_exists,
        "file-hash": cmd_file_hash,
        "disk-usage": cmd_disk_usage,
        "search-files": cmd_search_files,
        "append-file": cmd_append_file,
    }

    if binary in builtins:
        builtins[binary](args)
        return

    if binary not in ALLOWED:
        die(f"'{binary}' not allowed")
        return

    os.execv(ALLOWED[binary], [binary] + args)


if __name__ == "__main__":
    main()
